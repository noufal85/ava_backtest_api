from abc import ABC, abstractmethod
from dataclasses import dataclass, field
import polars as pl
import numpy as np
import math
from src.core.strategy.registry import register

@dataclass
class Signal:
    action: str          # "buy" | "sell" | "hold"
    strength: float      # 0.0 – 1.0
    confidence: float    # 0.0 – 1.0
    metadata: dict = field(default_factory=dict)

class BaseStrategy(ABC):
    name: str = ""
    version: str = "1.0.0"
    description: str = ""
    category: str = ""   # trend | mean_reversion | momentum | multi_factor | volatility
    tags: list[str] = []

    @abstractmethod
    def get_warmup_periods(self) -> int: ...

    @abstractmethod
    def generate_signal(self, window) -> Signal | None:
        # window.current_bar()   → polars DataFrame row (current bar)
        # window.historical()    → polars DataFrame of all historical bars
        # Columns: open, high, low, close, volume (float64), timestamp (date)
        # Combine: pl.concat([window.historical(), window.current_bar()])
        # NEVER look ahead
        ...

    def get_parameter_schema(self) -> dict:
        return {}

@register
class TvDrawdownCircuitBreaker(BaseStrategy):
    name = "tv_drawdown_circuit_breaker"
    version = "1.0.0"
    description = "DrawdownCircuitBreaker Strategy: STUB - Risk management overlay not applicable as standalone strategy"
    category = "multi_factor"
    tags = []

    def __init__(self):
        pass

    def get_warmup_periods(self) -> int:
        return 0

    def generate_signal(self, window) -> Signal | None:
        return None

    def get_parameter_schema(self) -> dict:
        return {}